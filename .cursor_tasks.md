Below is an exhaustive, one-story-point, **unchecked** markdown checklist that an autonomous coding agent can follow from zero to a fully-packaged Dioxus desktop application.  
Each checkbox is intentionally **small-scoped** (â‰ˆ Â½ day or less of work for a competent developer) and ordered so that every dependency, edge-case and artefact is covered.

---

# ðŸ—‚ï¸ RepoPrompt Clone â€” Detailed Implementation Checklist

> **Legend**  
> â€¢ "CI" = Continuous Integration (GitHub Actions assumed)  
> â€¢ "All OSes" = Windows 10 +, macOS 12 +, Ubuntu 22.04 LTS (x86-64) unless otherwise noted  
> â€¢ "DX" = Developer Experience  
> â€¢ `â€¦` = replace with your project-specific value  

---

## Story 0 â€” Project Foundations & Tooling

> _Goal: a reproducible repo skeleton, sane linting, formatting, CI and docs scaffolding._

### 0.1 Version-control & Repo Hygiene  
- [x] Create / init remote Git repository `repo_prompt_clone` (private or public).  
- [x] Add `.gitignore` using `cargo new --vcs=git` template + custom ignores for `/target`, `/dist`, IDE folders.  
- [x] Configure default branch to `main` (GitHub) and protect with PR reviews.  

### 0.2 Rust & System Toolchain  
- [x] `rustup update stable` to latest channel (record commit hash in `docs/dev_setup.md`).  
- [x] Add nightly toolchain _only_ if a crate requires it; otherwise pin to stable via `rust-toolchain.toml`.  
- [x] Install `wasm32-unknown-unknown` target for future Web builds (`rustup target add wasm32-unknown-unknown`).  
- [x] Verify build on all OSes (CI matrix) with default linker (`cargo +stable check`).  

### 0.3 Editor / Linter DX  
- [x] Install `rust-analyzer` VS Code extension; document in `docs/dev_setup.md`.  
- [x] Add `rustfmt.toml` (edition = 2021, tab_spaces = 4, newline_style = Unix).  
- [x] Add `clippy.toml` (deny warnings on CI, allow pedantic locally).  

### 0.4 CI Pipeline (GitHub Actions)  
- [x] Create `.github/workflows/ci.yml` with **matrix** (OS x toolchain).  
- [x] Steps: checkout â†’ cache cargo â†’ `cargo fmt --check` â†’ `cargo clippy --all-targets --all-features -- -D warnings` â†’ `cargo test`.  
- [x] Upload unit-test coverage via `cargo-tarpaulin` (Linux only) to Codecov.  

### 0.5 Project Docs & Issue Templates  
- [x] Write `README.md` with purpose, screenshots placeholder, build badges.  
- [x] Add `docs/architecture_overview.md` summarising Dioxus-Desktop vs Tauri choice.  
- [x] Create `.github/ISSUE_TEMPLATE/bug_report.yml` + `feature_request.yml`.  

---

## Story 1 â€” Minimal Dioxus Desktop App

> _Goal: launch a "Hello World" native window with hot-reload._

### 1.1 Cargo Scaffold  
- [ ] `cargo new --bin repo_prompt_clone` (if not already).  
- [ ] Commit empty project to Git (tag `v0.0.0`).  

### 1.2 Core Dependencies  
- [ ] Add to `Cargo.toml`:  
  ```toml
  dioxus         = { version = "0.5", features = ["desktop"] }
  dioxus-desktop = "0.5"
  tokio          = { version = "1", features = ["macros", "rt-multi-thread"] }
  ```  
- [ ] `cargo check` to ensure compilation.  

### 1.3 Main Entrypoint  
- [ ] In `src/main.rs`, `fn main() { dioxus_desktop::launch(app); }`.  
- [ ] Define `app(cx: Scope) -> Element` returning `rsx!( div { "Hello, RepoPrompt Clone!" } )`.  
- [ ] Run `cargo run` and confirm native window opens.  

### 1.4 Live-reload Workflow  
- [ ] `cargo install dioxus-cli` (document min version).  
- [ ] Add DX script `make dev` â†’ `dx serve`, with auto-open in default browser on WASM fallback.  
- [ ] Verify hot-reloading edits to `app` reflect instantly.  

### 1.5 Cross-Platform Smoke Test  
- [ ] Build and execute on Windows, macOS, Linux to ensure fonts and window chrome render correctly.  

---

## Story 2 â€” Folder/Workspace Selection

> _Goal: user chooses a directory, path persisted to "recent workspaces."_

### 2.1 Add Native File-Dialog Crate  
- [ ] Add `rfd = "0.14"` to `Cargo.toml`; run `cargo check`.  

### 2.2 Toolbar UI  
- [ ] Create `components/toolbar.rs`: render **"Open Folderâ€¦"** button.  
- [ ] On click, call `rfd::AsyncFileDialog::new().pick_folder().await`.  
- [ ] Handle `None` gracefully (user cancel).  

### 2.3 State Storage  
- [ ] Introduce `use_state::<Option<PathBuf>>()` in root component for `workspace_dir`.  
- [ ] After selection â†’ set state + trigger crawl task (future story).  

### 2.4 Recent Workspaces Persistence  
- [ ] Define `~/.config/repo_prompt_clone/settings.json` (use `dirs-next` crate for cross-platform config dir).  
- [ ] Write helper `settings::push_recent(path: &Path)` serialised via `serde_json`.  
- [ ] On app start, deserialize settings and pre-populate toolbar dropdown with the last 5 paths.  

### 2.5 Unit Tests  
- [ ] Add tests for `settings` read/write (mock with `tempdir`).  

---

## Story 3 â€” Basic File Listing (Non-Recursive)

> _Goal: list immediate files under selected root with minimal metadata._

### 3.1 Domain Model  
- [ ] Create `struct FileInfo { name: String, path: PathBuf, size: u64, token_count: usize }`.  
- [ ] Implement `Debug`, `Clone`, `PartialEq`, `serde::{Serialize,Deserialize}`.  

### 3.2 Synchronous Directory Enumeration  
- [ ] Write helper `fs_utils::read_children(dir: &Path) -> io::Result<Vec<FileInfo>>`.  
- [ ] Skip directories, `.git`, hidden files by default (configurable later).  

### 3.3 Thread Off-loading  
- [ ] Spawn enumeration via `tokio::task::spawn_blocking` to avoid UI stall.  
- [ ] Pipe result back through `tao::event::Event::UserEvent` or Dioxus channel.  

### 3.4 UI Rendering  
- [ ] Create `components/file_list.rs` rendering `<ul>` with filename + size (human-readable).  
- [ ] Conditionally render empty-state placeholder ("No files loaded yet").  

### 3.5 Formatting Helpers  
- [ ] Add `bytesize = "1.3"` crate; display sizes e.g. "42.7 KB".  

### 3.6 Smoke Tests  
- [ ] Unit test `read_children` with a scratch dir containing 3 files of known size.  

---

## Story 4 â€” Recursive Crawl & Token Counting

> _Goal: walk entire tree, compute token lengths concurrently._

### 4.1 Add Tokenizer Crates  
- [ ] Add  
  ```toml
  tiktoken-rs = "0.2"   # GPT-style BPE
  tokenizers  = "0.19"  # HF SentencePiece
  ```  
- [ ] Feature-gate crates behind `cfg` flags if bloat is an issue (`tokenizers` heavy).  

### 4.2 Recursive Traversal Function  
- [ ] Implement `async fn crawl(dir) -> Vec<FileInfo>` using `walkdir = "2"` for convenience.  
- [ ] Respect `.gitignore` if present (add `ignore = "0.4"` crate for git-style filters).  
- [ ] For each file: stream-read to `String` (limit 2 MB or user-configurable).  

### 4.3 Concurrent Tokenisation  
- [ ] Spawn `tokio::task::spawn` per file (bounded `Semaphore` to 8 threads).  
- [ ] Use selected estimator (`enum TokenEstimator`) stored in app state.  
- [ ] Persist `{path, mtime, token_count, hash}` cache to `$CONFIG_DIR/cache.db` (SQLite via `rusqlite` or simple JSON).  

### 4.4 Progress Bar UX  
- [ ] Add `components/progress_modal.rs` that receives `(completed, total)` updates via `Signal`.  
- [ ] Show percentage during crawl; hide on finish or cancel.  

### 4.5 Integration Test  
- [ ] Create fixture directory tree in `tests/fixtures/project_a` and assert aggregated file count matches expectation.  

---

## Story 5 â€” File Selection & Checkbox Logic

> _Goal: user can select/deselect individual or all files._

### 5.1 Selection State Hook  
- [ ] `use_state::<HashSet<PathBuf>>()` called `selected_files`.  

### 5.2 Row Checkbox Component  
- [ ] For each `FileInfo`, render:  
  ```rust
  input { 
      r#type: "checkbox",
      checked: selected_files.contains(path),
      onclick: |_| toggle_selected(path.clone())
  }
  span { "{name}" }
  ```  
- [ ] `toggle_selected` adds/removes from `HashSet`.  

### 5.3 Bulk Actions  
- [ ] Add toolbar buttons **"Select All"** and **"Deselect All"** (operate on current filtered view).  

### 5.4 Keyboard Shortcuts  
- [ ] Implement `Ctrl/Cmd + A` (select all) and `Esc` (deselect all) via `dioxus-desktop` global hotkey API.  

### 5.5 Unit Tests  
- [ ] Test that "Select All" selects exactly `visible_files.len()` after a filter is applied.  

---

## Story 6 â€” Token Estimator Switching

> _Goal: runtime dropdown to pick encoder; all token counts update accordingly._

### 6.1 Dropdown UI  
- [ ] Add `<select>` in toolbar with options: **Char/4 heuristic**, **GPT-3/4 (cl100k)**, **Llama2 BPE**, **Gemini SentencePiece**.  

### 6.2 Estimator Enum  
- [ ] `enum TokenEstimator { CharDiv4, Cl100k, Llama2, SentencePiece }`.  
- [ ] Persist chosen estimator in settings JSON.  

### 6.3 Re-compute Token Counts  
- [ ] On change: invalidate in-memory cache, re-crawl token counts but **reuse** file content hashes to skip IO.  
- [ ] Show modal "Re-estimating tokensâ€¦" with progress.  

### 6.4 Unit Test  
- [ ] For small sample file "Hello world", ensure estimator switch returns consistent expected counts.  

---

## Story 7 â€” Aggregate Counts & Footer Display

> _Goal: real-time total token count for selected files._

### 7.1 Derived Signal  
- [ ] `use_memo` on `(selected_files, file_map)` â†’ `usize` total.  
- [ ] Update on any selection change.  

### 7.2 Footer Component  
- [ ] Fixed bottom bar with `div { "Total tokens: {total}" }`.  
- [ ] Tooltip: "Estimation via {estimator_name}."  

### 7.3 Overflow Indicator  
- [ ] If total > 32k tokens, colour text red and show warning icon.  

### 7.4 Unit Test  
- [ ] Simulate selecting three fixture files; assert footer displays sum.  

---

## Story 8 â€” Sorting & Column Headers

> _Goal: sort list by name, size or tokens (asc/desc)._

### 8.1 Column Header Component  
- [ ] Add clickable headers: **Name**, **Size**, **Tokens**.  
- [ ] On click toggle `(sort_by, dir)` state tuple.  

### 8.2 Stable Sort Implementation  
- [ ] Use `Vec<FileInfo>` clones and `sort_by_cached_key` for performance.  
- [ ] Memoise result so UI only re-sorts when dependency changes.  

### 8.3 Visual Indicator  
- [ ] Append â–²/â–¼ icon using Heroicons via SVG `rsx!`.  
- [ ] Accessibility: `aria-sort` attribute.  

### 8.4 Unit Test  
- [ ] Assert that sorting by size desc returns largest file first in rendered order.  

---

## Story 9 â€” Concatenate + Copy to Clipboard

> _Goal: produce consolidated text of selected files and copy to OS clipboard._

### 9.1 Concatenation Logic  
- [ ] Create async fn `concat_files(paths: &[PathBuf]) -> io::Result<String>`.  
- [ ] Insert delimiter `"\n\n/* ---- {relative_path} ---- */\n\n"` between files.  

### 9.2 Clipboard Integration  
- [ ] Add `arboard = "3"` dependency.  
- [ ] Fallback: if clipboard write fails, save to temp file and open file-manager reveal.  

### 9.3 UI Entry Point  
- [ ] Toolbar **"Copy Selected Files"** button disabled if `selected_files.is_empty()`.  
- [ ] On success: flash toast "Copied âœ…"; on error: toast "Copy failed âŒ (see logs)".  

### 9.4 Error Telemetry  
- [ ] Log concatenation errors via `tracing` crate to file at `$CONFIG_DIR/app.log`.  

### 9.5 Integration Test (Mock)  
- [ ] Mock `arboard::Clipboard` using trait abstraction; assert string contains both file headers.  

---

## Story 10 â€” Filtering Input

> _Goal: filter visible rows by substring, extension or regex._

### 10.1 Filter State  
- [ ] `use_state::<String>()` called `filter_query`.  

### 10.2 Search Box UI  
- [ ] Debounce `oninput` with 200 ms timer (`gloo_timers::Callback`).  
- [ ] Placeholder text: "Filter by name, ext (.rs), or regex /pattern/gi".  

### 10.3 Filter Predicate  
- [ ] If query wrapped in `/â€¦/i?`, compile `regex::Regex` and use `is_match`.  
- [ ] Else if query has `.` followed by chars, treat as extension filter.  
- [ ] Else substring, case-insensitive.  

### 10.4 Selection Trimming  
- [ ] After filter change, iterate `selected_files` and remove paths no longer visible.  

### 10.5 Keyboard Shortcut  
- [ ] `Ctrl/Cmd + F` focuses search box.  

### 10.6 Unit Tests  
- [ ] Validate that filter ".rs" returns only Rust files in fixture tree.  
- [ ] Regex `/main\w+/i` matches "main.rs" and not "domain.rs".  

---

## Story 11 â€” Styling with Tailwind

> _Goal: pleasant, responsive UI with minimal CSS bundle._

### 11.1 Tailwind Integration  
- [ ] Add `dioxus-tailwind-class = "0.3"` (or macro-free utility classes inline).  
- [ ] Install `tailwindcss` & `postcss` via `npm devDependencies`.  
- [ ] Create `tailwind.config.cjs` â†’ `content: ["./src/**/*.rs"]`, enable JIT.  

### 11.2 Build Script  
- [ ] Add `build.rs` to compile Tailwind â†’ `static/tailwind.css` at build time (use `tailwindcss -m src -o ...`).  
- [ ] Embed CSS via `include_str!()` and inject into `<style>` tag at runtime.  

### 11.3 Theme Decisions  
- [ ] Adopt neutral gray palette, `font-sans` (Inter).  
- [ ] Add dark-mode support toggled by OS scheme (prefers-color-scheme).  

### 11.4 Visual Polish  
- [ ] Implement hover states for list rows, sticky toolbar/footer, toast transition (opacity/slide).  
- [ ] Ensure high-DPI icons render crisp (SVG).  

### 11.5 Manual QA  
- [ ] Zoom browser 200 % and verify no overflow.  
- [ ] Run `axe-core` accessibility audit; fix contrast violations.  

---

## Story 12 â€” Packaging & Distribution

> _Goal: deliver signed binaries for Windows, macOS & Linux.*

### 12.1 Platform Icons  
- [ ] Create 1024Ã—1024 PNG and convert to `.ico` & `.icns` via `magick`.  
- [ ] Add `build.rs` embedding for Windows icon.  

### 12.2 Mac Codesign & Notarisation  
- [ ] Generate Developer ID cert; configure `cargo-bundle --release`.  
- [ ] Automate notarisation in CI via `apple/notarize-action`.  

### 12.3 Windows Installer  
- [ ] Use `cargo-wix` to generate MSI; sign with Azure SignTool.  

### 12.4 Linux AppImage / Deb  
- [ ] Package via `cargo-deb`; additionally create AppImage with `appimage-build`.  

### 12.5 Auto-Update (Optional with Tauri)  
- [ ] If switching to Tauri: enable `tauri::updater` with GitHub releases JSON feed.  

### 12.6 Release Pipeline  
- [ ] Tag `v1.0.0`, GitHub Action builds artefacts, attaches to draft release.  
- [ ] Write CHANGELOG entry summarising features.  

---

## Story 13 â€” Telemetry & Crash Reporting (Stretch)

> _Optional but recommended for production._

- [ ] Add opt-in checkbox on first launch "Send anonymous usage data".  
- [ ] Integrate `sentry` crate (DSN env variable).  
- [ ] Capture panics via `sentry::init` and show polite crash dialog.  

---

## Story 14 â€” End-to-End QA Checklist

> _Goal: ensure final artefacts meet functional, performance and UX criteria._

- [ ] Manual walkthrough of all flows on each OS (folder open, filter, select, copy).  
- [ ] Measure memory footprint < 120 MB after loading 1k files.  
- [ ] Verify start-to-ready time < 800 ms on M1 MacBook Air (release build).  
- [ ] Confirm clipboard content matches concatenation spec for 3 sample files.  
- [ ] Accessibility: can operate entirely via keyboard and screen-reader announces buttons.  
- [ ] Localisation placeholder: wrap user-visible strings in `gettext!()` macro.  

---

## Story 15 â€” Documentation & On-boarding

> _Final mile: user & developer guidance._

- [ ] Update `README.md` with installation table (Win/macOS/Linux).  
- [ ] Record 30-sec gif demo (Peek) and embed in README.  
- [ ] Write `CONTRIBUTING.md` with branching model, code style, test instructions.  
- [ ] Publish Rust docs to docs.rs via `cargo publish`.  
- [ ] Create GitHub Discussions / Q&A category.  

---

### âœ… Completion Criteria

- All checkboxes above are ticked in PRs.  
- CI green across platforms.  
- Release `v1.0.0` binaries downloadable and virus-scanned.  
- README badge shows 100 % unit-test pass & > 80 % coverage.  

---

**Now hand this checklist to your AI coding agent and start shipping! ðŸš€**